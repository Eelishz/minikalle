use shakmaty::{Board, Chess, Color, Outcome, Position, Role};

const POSITIVE_INFINITY: i32 = 999999999;
const NEGATIVE_INFINITY: i32 = -999999999;

const SCALE_FACTOR: i32 = 1000;

const WEIGHTS: [i32; 769] = [
    0, 10, 10, 10, 10, 10, 10, 10, 10, //
    10, 10, 10, 10, 10, 10, 10, 10, //
    10, 10, 10, 10, 10, 10, 10, 10, //
    10, 10, 10, 10, 10, 10, 10, 10, //
    10, 10, 10, 10, 10, 10, 10, 10, //
    10, 10, 10, 10, 10, 10, 10, 10, //
    10, 10, 10, 10, 10, 10, 10, 10, //
    10, 10, 10, 10, 10, 10, 10, 10, ////
    30, 30, 30, 30, 30, 30, 30, 30, //
    30, 30, 30, 30, 30, 30, 30, 30, //
    30, 30, 30, 30, 30, 30, 30, 30, //
    30, 30, 30, 30, 30, 30, 30, 30, //
    30, 30, 30, 30, 30, 30, 30, 30, //
    30, 30, 30, 30, 30, 30, 30, 30, //
    30, 30, 30, 30, 30, 30, 30, 30, //
    30, 30, 30, 30, 30, 30, 30, 30, ////
    30, 30, 30, 30, 30, 30, 30, 30, //
    30, 30, 30, 30, 30, 30, 30, 30, //
    30, 30, 30, 30, 30, 30, 30, 30, //
    30, 30, 30, 30, 30, 30, 30, 30, //
    30, 30, 30, 30, 30, 30, 30, 30, //
    30, 30, 30, 30, 30, 30, 30, 30, //
    30, 30, 30, 30, 30, 30, 30, 30, //
    30, 30, 30, 30, 30, 30, 30, 30, ////
    50, 50, 50, 50, 50, 50, 50, 50, //
    50, 50, 50, 50, 50, 50, 50, 50, //
    50, 50, 50, 50, 50, 50, 50, 50, //
    50, 50, 50, 50, 50, 50, 50, 50, //
    50, 50, 50, 50, 50, 50, 50, 50, //
    50, 50, 50, 50, 50, 50, 50, 50, //
    50, 50, 50, 50, 50, 50, 50, 50, //
    50, 50, 50, 50, 50, 50, 50, 50, // //
    80, 80, 80, 80, 80, 80, 80, 80, //
    80, 80, 80, 80, 80, 80, 80, 80, //
    80, 80, 80, 80, 80, 80, 80, 80, //
    80, 80, 80, 80, 80, 80, 80, 80, //
    80, 80, 80, 80, 80, 80, 80, 80, //
    80, 80, 80, 80, 80, 80, 80, 80, //
    80, 80, 80, 80, 80, 80, 80, 80, //
    80, 80, 80, 80, 80, 80, 80, 80, ////
    0, 0, 0, 0, 0, 0, 0, 0, //
    0, 0, 0, 0, 0, 0, 0, 0, //
    0, 0, 0, 0, 0, 0, 0, 0, //
    0, 0, 0, 0, 0, 0, 0, 0, //
    0, 0, 0, 0, 0, 0, 0, 0, //
    0, 0, 0, 0, 0, 0, 0, 0, //
    0, 0, 0, 0, 0, 0, 0, 0, //
    0, 0, 0, 0, 0, 0, 0, 0, ////
    -10, -10, -10, -10, -10, -10, -10, -10, //
    -10, -10, -10, -10, -10, -10, -10, -10, //
    -10, -10, -10, -10, -10, -10, -10, -10, //
    -10, -10, -10, -10, -10, -10, -10, -10, //
    -10, -10, -10, -10, -10, -10, -10, -10, //
    -10, -10, -10, -10, -10, -10, -10, -10, //
    -10, -10, -10, -10, -10, -10, -10, -10, //
    -10, -10, -10, -10, -10, -10, -10, -10, ////
    -30, -30, -30, -30, -30, -30, -30, -30, //
    -30, -30, -30, -30, -30, -30, -30, -30, //
    -30, -30, -30, -30, -30, -30, -30, -30, //
    -30, -30, -30, -30, -30, -30, -30, -30, //
    -30, -30, -30, -30, -30, -30, -30, -30, //
    -30, -30, -30, -30, -30, -30, -30, -30, //
    -30, -30, -30, -30, -30, -30, -30, -30, //
    -30, -30, -30, -30, -30, -30, -30, -30, ////
    -30, -30, -30, -30, -30, -30, -30, -30, //
    -30, -30, -30, -30, -30, -30, -30, -30, //
    -30, -30, -30, -30, -30, -30, -30, -30, //
    -30, -30, -30, -30, -30, -30, -30, -30, //
    -30, -30, -30, -30, -30, -30, -30, -30, //
    -30, -30, -30, -30, -30, -30, -30, -30, //
    -30, -30, -30, -30, -30, -30, -30, -30, //
    -30, -30, -30, -30, -30, -30, -30, -30, ////
    -50, -50, -50, -50, -50, -50, -50, -50, //
    -50, -50, -50, -50, -50, -50, -50, -50, //
    -50, -50, -50, -50, -50, -50, -50, -50, //
    -50, -50, -50, -50, -50, -50, -50, -50, //
    -50, -50, -50, -50, -50, -50, -50, -50, //
    -50, -50, -50, -50, -50, -50, -50, -50, //
    -50, -50, -50, -50, -50, -50, -50, -50, //
    -50, -50, -50, -50, -50, -50, -50, -50, ////
    -80, -80, -80, -80, -80, -80, -80, -80, //
    -80, -80, -80, -80, -80, -80, -80, -80, //
    -80, -80, -80, -80, -80, -80, -80, -80, //
    -80, -80, -80, -80, -80, -80, -80, -80, //
    -80, -80, -80, -80, -80, -80, -80, -80, //
    -80, -80, -80, -80, -80, -80, -80, -80, //
    -80, -80, -80, -80, -80, -80, -80, -80, //
    -80, -80, -80, -80, -80, -80, -80, -80, ////
    0, 0, 0, 0, 0, 0, 0, 0, //
    0, 0, 0, 0, 0, 0, 0, 0, //
    0, 0, 0, 0, 0, 0, 0, 0, //
    0, 0, 0, 0, 0, 0, 0, 0, //
    0, 0, 0, 0, 0, 0, 0, 0, //
    0, 0, 0, 0, 0, 0, 0, 0, //
    0, 0, 0, 0, 0, 0, 0, 0, //
    0, 0, 0, 0, 0, 0, 0, 0, ////
];

pub struct Evaluator {
    weights: [i32; 769],
}

impl Evaluator {
    pub fn new() -> Self {
        Evaluator { weights: WEIGHTS }
    }

    fn encode_board(&self, board: &Board) -> Vec<i32> {
        Color::ALL
            .iter()
            .flat_map(|&color| {
                Role::ALL.iter().flat_map(move |&role| {
                    let color_board = board.by_color(color);
                    let role_board = board.by_role(role);
                    let combined_board = color_board.intersect(role_board);

                    combined_board.into_iter().map(|x| x as i32)
                })
            })
            .collect()
    }

    fn count_pieces(&self, position: Chess) -> i32 {
        let white_material = position.board().material_side(Color::White);
        let black_material = position.board().material_side(Color::Black);

        white_material.pawn as i32 * 100
            + white_material.knight as i32 * 350
            + white_material.bishop as i32 * 300
            + white_material.rook as i32 * 500
            + white_material.queen as i32 * 900
            - black_material.pawn as i32 * 100
            - black_material.knight as i32 * 350
            - black_material.bishop as i32 * 300
            - black_material.rook as i32 * 500
            - black_material.queen as i32 * 900
    }

    fn score(&self, position: Chess, weights: [i32; 769]) -> i32 {
        let bits = self.encode_board(&position.board());
        let mut evaluation = 0;

        for (i, bit) in bits.into_iter().enumerate() {
            let bit = bit * SCALE_FACTOR;
            let a = weights[0];
            let b = weights[i + 1];

            evaluation += a + bit * b
        }

        evaluation as i32
    }

    pub fn evaluate(&self, position: Chess, depth_from_root: u8) -> i32 {
        let evaluation = match position.outcome() {
            Some(Outcome::Draw) => return 0,
            Some(Outcome::Decisive { winner }) => {
                if winner == Color::White {
                    POSITIVE_INFINITY - depth_from_root as i32
                } else {
                    NEGATIVE_INFINITY + depth_from_root as i32
                }
            }
            None => self.count_pieces(position.clone()),
        };
        if position.turn() == Color::Black {
            -evaluation
        } else {
            evaluation
        }
    }
}
